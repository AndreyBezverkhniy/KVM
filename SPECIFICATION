СПЕЦИФИКАЦИЯ ЯЗЫКА KIRPITCH 1.0


ОГЛАВЛЕНИЕ
1. Введение
2. Комментарии
3. Инструкция var
4. Вычисление выражения
5. Конструкция if
6. Конструкция while
7. Пользовательские функции
8. Инструкция return
9. Встроенные функции
10. Операторы в выражениях
11. Чтение исходных файлов
12. Инструкция import
13. Обработка объявлений function


1. ВВЕДЕНИЕ
Язык Kirpitch 1.0 поддерживает работу с переменными единственного типа int32.
Результат всех операций всегда int32. Если предполагается использование
логических значений числа преобразуются по правилу: 0 считается false, любое
другое число - true. Язык поддерживает создание программ из нескольких файлов.
Язык поддерживает однострочные и многострочные комментарии, не влияющие на
выполнение программы.
Алгоритм работы интерпретатора:
1) При чтении обрабатываются все инструкции import
2) После чтения всей программы ищутся все объявления пользовательских функций
3) Выполняются инструкции
Базовые инструкции и конструкции: var, if, while, return
Если в процессе выполнения встречено нечто иное, нежели базовая инструкция или
конструкция, инструкция считается выражением, которое интерпретатор пытается
вычислить.
Инструкции заканчиваются ';'. Инструкции можно объеденять в блоки {...}, блоки
могут быть пустыми. Конструкции if и while после условия требуют блок
инструкций для выполнения if/while () {...}


2. КОММЕНТАРИИ
Однострочные комментарии начинаются с "//" и продолжается до конца строки.
Многострочные комментарии заключаются между "/*" и "*/". Вложенные
многострочные комментарии не поддерживаются.


3. ИНСТРУКЦИЯ VAR
Объявление переменных осуществляется инструкцией var:
var name1[,name2[,name3...]];
В объявлении можно сразу присваивать значение переменной:
var name=expression;
Запрещено использовать имена переменных, совпадающие с именами пользовательских
или встроенных функций.
В имени переменной разрешено использовать цифры, буквы английского алфавита и
символ '_'. Имя переменной не может начинаться с цифры.
Повторное объявление переменной с тем же именем на одном уровне вложенности
блока запрещено, но объявление во вложенном блоке разрешено:
{
	var name=10;
	// var name; - ошибка
	{
		var name=20; // новая переменная
	}
	// name снова 10
}


4. ВЫЧИСЛЕНИЕ ВЫРАЖЕНИЯ
Выражение - последовательность операндов, операторов и круглых скобок.
Операндом может быть число, переменная, результат вызова функции с аргументами.
Операнды могут быть бинарными, левыми унарными и правыми унарными. Выражение
само по себе вне контекста другой инструкции тоже выполняется как инструкция.
Присвоение значения ранее объявленной переменной - та же самая инструкция
"выражение", работающая за счёт поддержки в выражениях бинарного оператора
присвоения '='.

5. КОНСТРУКЦИЯ IF
Имеет вид: if(expression){...}
Если результат вычисления expression не 0, то код внутри блока выполняется.

6. КОНСТРУКЦИЯ WHILE
Имеет вид: while(expression){...}
Пока результат вычисляемого expression не 0, выполняет код внутри блока.

7. ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ
Язык поддерживает объявление соственных функций. Объявление функции имеет вид:
function functionName([arument1[,argument2[,argument3...]]]) {...}
Правила задания имён функций такое же как для переменных.
По умолчанию функции возвращают 0, но это значение можно явно изменить
инструкцией return.
Функции могут принимать аргументы, правила задания имён которых такие же как у
обычных переменных.
Аргументы - временные переменные, существуют пока выполняется функция.
Объявлять новую переменную с именем, совпадающим с именем одноого из
аргументов, можно начиная с основного блока тела функции (и далее во вложенных
блоках, очевидно). Аргументы инициализированны значениями, посланными в функцию
при её выхове.

8. ИНСТРУКЦИЯ RETURN
Имеет вид: return expression;
Первостепенно инструкция создана для завершения выполнения текущей функции и
задания возвращаемого значения. Однако инструкция может применяться и в коде
вне функций. В этом случае возвращаемое значение роли не играет, а программы
завершает своё выполнение.

9. ВСТРОЕННЫЕ ФУНКЦИИ
Язык поддерживает 2 встроенные функции:
write([argument1[,argument2...]]) - выводит через пробел свои аргументы в
консоль и переводит на новую строку в конце
read() - инициализирует чтение числа из консоли и возвращает это число

10. ОПЕРАТОРЫ В ВЫРАЖЕНИЯХ
Математические бинарные операторы: +, -, *, /, % - работают очевидным образом.
Бинарные операторы сравнения: ==, !=, >, <, >=, <= - возвращают 1 в стулае
истины, иначе 0.
Логические бинарные операторы: ||, && - воспринимают числовые операнды за
логические по правилу: 0 - это ложь, остальное истина. Результат,
соответственно, либо ложь (0), либо истина (именно 1).
Бинарный оператор присвоения '=' требует, чтобы левый операнд был переменной.
Присваивает этой переменной значение правого операнда.
Левые унарные операторы: --, ++, -, +, !. Оператор ! - логическое НЕ. Левые
инкремент и декремент применяются только к переменным и изменяют значение
переменной на 1, возвращая саму переменную, т.е. значением выражения будет
актуальное значение переменной, и к результату останется возможность применять
операторы, работающие только с переменными.
Правые унарные операторы: --, ++. Правые инкремент и декремент применяются
только к переменным и изменяют значение переменной на 1, возвращая 
старое значение.
Порядок вычисления выражения: сначала вычисляются скобки, затем применяются
все левые унарные операторы (справа-налево), затем все правые унарные
операторы (слева-направо), зате бинарные операторы по порядку понижения
приоритета слева-направо. Исключением из правила является бинарный оператор
присвоения. Он имеет наименьший приоритет и вычисляется последним, но не
слева-направо, как остальные бинарные операторы, а справа-налево. Т.е. цепочка
присвоений variable1=...=variableN=expression проинициализирует все переменные
от variable1 до variableN значением выражения expression.

11. ЧТЕНИЕ ИСХОДНЫХ ФАЙЛОВ
Исходные файлы разбиваются на литералы. Литерал - это объект, содержащий
строку, идентификатор иепа литерала и состояние литерала. Литералы строятся
посимвольно. Каждый новый символ из исходного файла добавляется к литералу, и
либо продолжает литерал, либо завершает и начинает новый, либо нарушает
структуру литерала.
Типы литералов:
	EMPTY: новый чистый литерал
	SPACES: содержит только пробелы, символы табуляции, переноса строки и
	        переноса каретки
	WORD: содержит цифры, английские буквы и символ '_'
	STRING: любой текст без символа ", заключённый в кавычки "..."
	SIGN: любой одиночный символ запрешённый быть в начале пробельного,
	      строкового литерала и слова, а так же 2-х символьные операторы:
	      ++, --, ==, !=, >=, <=, || и &&
	INLINECOMMENT: литерал однострочного комментария
	MULTILINECOMMENT: литерал многострочного комментария
	LITERALEOF: литерал конца файла: создаётся только вручную и добавляется
в конец всей прочитанной программы (массив литералов после развёртывания всех
инструкций import)
Разбор файлов на литералы - первый этап прочтения программы. На первом этапе
обрабатываются инструкции import. Второй этап - обработка объявления функций в
прочитанной программе (массиве литералов).

12. ИНСТРУКЦИЯ IMPORT
Имеет вид: import srс_file_path_string;
На первом этапе прочтения программы при встрече последовательности литералов
WORD(import) STRING SIGN(;) эта последовательность заменяется на массив
литералов, считанный из файла srс_file_path_string (в котором уже тоже
развёрнуты инструкции import). Весь массив литералов (вся программа)
дополняется завершающим литералом LITERALEOF конца всей программы. Рекурсивные
импорты отслеживаются и запрещены явно.

13. ОБРАБОТКА ОБЪЯВЛЕНИЙ FUNCTION
После прочтения программы (массива литералов) интерпретатор собрать информацию
об именах, аргументах пользовательских (их имена и количество аргументов)
функций и точек начала их выполнения (номер литерала, с которого начинается
тело функции, т.е. литерал после открытия '{' основного блока функции).
Перегрузка функций с одинаковымиименами запрещена.

